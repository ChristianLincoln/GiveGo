Give Go — Full-Stack PWA Build Prompt Overview Build a full-stack Progressive Web App (PWA) called Give Go. It's a single, unified PWA that serves two user types: Players who collect coins in the real world using GPS. Sponsors who purchase coins to fund charity donations. Give Go is a GPS-based game. Players collect coins that sponsors have placed (virtually) in public spaces. Every coin collected triggers a donation to the British Heart Foundation. Funds are held in escrow from the moment a sponsor pays, and are only released to the charity when a player collects the coin. If a coin expires uncollected, the funds remain in escrow and the coin returns to the sponsor's inventory for future use. 1. PWA Requirements 1.1 Progressive Web App Setup The app must be installable on mobile devices (iOS and Android). Include a manifest.json with appropriate icons, name, short_name, theme colors, and display mode set to "standalone". Implement a service worker for offline capability and app-like experience. The PWA should feel native when installed (no browser UI, proper splash screen). Ensure responsive design that works on mobile, tablet, and desktop screens. Use the Geolocation API for accessing device location. 1.2 User Role Selection After the initial login/signup, users must select their role: Player or Sponsor. Store the selected role in the user profile (users can switch roles later via settings). Based on the role, show the appropriate interface (Player Dashboard or Sponsor Dashboard). A single account can access both roles, but the user explicitly chooses which mode they're in. 2. Player Interface 2.1 Login / Signup The first screen is a unified login/signup page. Users authenticate with email and password. After authentication, if they select "Player" mode, the app must request location permissions before proceeding. Show a clear modal/dialog explaining: "We need your location to place coins near you and to verify collection." If the user denies location permission, show a friendly message: "Give Go requires location access to function. Please enable location in your browser settings." Provide a retry button. On browsers that don't support geolocation, show an error message explaining the app requires location services. 2.2 Player Dashboard After login, location permission granted, and "Player" role selected, show the player dashboard. Display: Total coins collected (all-time). Total money donated to the British Heart Foundation (all-time, in GBP). Current global leaderboard rank. Leaderboard view: Show 4 players ranked above the current player, a visual separator (e.g., blur or dashed line), the current player's row (highlighted with distinct styling), another separator, and 4 players ranked below. Each row shows: rank, username, coins collected, and total donated. A line graph (using Chart.js or similar) showing the player's cumulative coins collected and cumulative amount donated over time. A prominent "Start Collecting" button to begin a new session. If no coins are available in any sponsor's inventory, display: "No coins available right now. Please check back later." and disable the button. Navigation menu to access: Dashboard, Active Session (if any), Coin History, Settings, Switch to Sponsor Mode. 2.3 Coin Collection Sessions Starting a Session A player can only have one active session at a time. If the player already has an active session, the "Start Collecting" button should navigate to the active session map instead. When a session starts, the backend randomly selects 1–10 coins from the combined inventory of all sponsors (or fewer if total inventory < 10). Each coin is placed at a random location 1–2 kilometres from the player's current position (fixed radius). Each coin is assigned a TTL (time to live). Coins expire when their TTL elapses. Navigate to the session map view. The Session Map Use a web mapping library (Leaflet, Mapbox GL JS, or Google Maps JavaScript API). Center the map on the player's current position. Show the player's location as a clearly visible marker that updates in real time as they move (using the Geolocation API's watchPosition). Draw a 10-metre collection radius around the player as a translucent circle. Each coin appears as a custom pin/marker labeled with its GBP value (e.g., "£2", "50p"). Coins that expire are automatically removed from the map in real time. Include standard map controls: zoom in/out, recenter on player. Collection trigger: When the player moves within 10 metres of a coin, either: Auto-collect (preferred for mobile), OR Show a "Collect" button overlay on that coin's marker. The 10-metre distance check must be verified server-side before confirming collection. Collecting a Coin Send the player's current position to the backend along with the coin_id. The backend calculates distance using the Haversine formula and rejects if > 10 metres. On successful collection: The coin disappears from the map. Show a celebratory modal/toast with the coin value and running session total. Update player stats in real time (total coins, total donated). Use WebSockets or Server-Sent Events (SSE) for real-time updates. Session End A session ends when: All coins are collected (status: completed), OR All coins have expired (status: abandoned). The player can manually give up at any time via a "Give Up" button. This expires all remaining coins, returns them to sponsor inventory, and marks the session as abandoned. Once a session ends, navigate back to the dashboard. The player can start a new session. 2.4 Coin History Page A separate page showing a map of every coin the player has ever collected. Each marker shows: GBP value, date/time collected. Tapping a marker can show additional details (e.g., running collection count at that time). Option to filter by date range or coin value. 3. Sponsor Interface The sponsor interface is part of the same PWA but with different views. 3.1 Sponsor Dashboard After selecting "Sponsor" mode, show the sponsor dashboard. Display: Total coins purchased (all-time). Coins currently in inventory (available, not placed in any session). Coins currently active (placed in live player sessions, not yet collected or expired). Coins collected by players (all-time) — equals total donated to the British Heart Foundation on this sponsor's behalf. Coins expired (returned to inventory). A graph showing donation trends over time (using Chart.js or similar). Navigation menu to access: Dashboard, Purchase Coins, Coin Tracking Map, Settings, Switch to Player Mode. 3.2 Coin Purchase A purchase page with input fields for each of the 12 denominations: 1p, 2p, 5p, 10p, 20p, 50p, £1, £2, £5, £10, £20, £50. Display each denomination with a quantity input (number stepper or text field). Show a live-updating total cost as quantities change (use reactive state). A "Purchase" button that initiates payment via Stripe Checkout (use Stripe.js). The total charged equals the face value of all selected coins. After successful payment: Stripe sends a webhook to the backend. Backend adds coins to sponsor's inventory and creates escrow records. Show a confirmation message: "Your coins have been added to your inventory!" Update the dashboard to reflect new inventory. 3.3 Coin Tracking Map A map showing all coins this sponsor has ever funded. Active coins (currently in a player session): bright, highlighted pins. Collected coins: greyed out or dimmed pins. Expired coins: distinct style (dashed outline or muted color). Coins in inventory (never placed): do not appear on the map. Map controls: zoom in/out. Filter UI: Toggle buttons or dropdown to view: All coins Active only Collected only Expired only Real-time updates when coins are collected or expire. 4. Backend — Database & API The backend serves the unified PWA and must support real-time updates (WebSockets or SSE). 4.1 Database Schema TableKey ColumnsUsersuser_id, auth_id, email, username, role (can be 'player', 'sponsor', or 'both'), created_atPlayerProfilesplayer_id, user_id, total_coins_collected, total_donated, created_atSponsorProfilessponsor_id, user_id, company_name, total_coins_purchased, total_donated, created_atCoinTypescoin_type_id, denomination (1p, 2p, 5p, 10p, 20p, 50p, £1, £2, £5, £10, £20, £50), value_gbpSponsorCoinInventoryinventory_id, sponsor_id, coin_type_id, quantity_available, quantity_purchased, created_atCoinGenerationSessionssession_id, player_id, session_start, session_end, status (active/completed/abandoned), coins_generated_countGeneratedCoinscoin_id, session_id, coin_type_id, sponsor_id, latitude, longitude, status (active/collected/expired), ttl_expires_at, created_at, collected_atPlayerCoinHistoryhistory_id, player_id, coin_id, coin_type_id, value_gbp, collected_at, latitude, longitudeEscrowTrackingescrow_id, sponsor_id, coin_id, amount_gbp, status (held/released/reserved), created_at, released_at 4.2 API Endpoints User Authentication POST /api/auth/signup — Create user account POST /api/auth/login — Authenticate user POST /api/auth/logout — End session GET /api/auth/me — Get current user profile and role Role Management POST /api/user/set-role — Set active role (player or sponsor) GET /api/user/profiles — Get player and/or sponsor profiles for the user Coin Generation (Player) POST /api/player/session/start Accepts: player_id, current latitude/longitude Rejects if player already has an active session Pulls 1–10 coins randomly from combined SponsorCoinInventory Places coins 1–2 km from player position Assigns TTL to each coin Decrements sponsor quantity_available Creates GeneratedCoins records (status: active) Creates EscrowTracking records (status: held) Creates CoinGenerationSessions record (status: active) Returns session and coin data Broadcasts update via WebSocket Coin Collection (Player) POST /api/player/coin/collect Accepts: player_id, coin_id, current latitude/longitude Server-side distance check using Haversine formula (must be ≤ 10m) Rejects if distance > 10m Updates GeneratedCoins (status: collected, collected_at) Creates PlayerCoinHistory record Updates PlayerProfile (total_coins_collected, total_donated) Updates EscrowTracking (status: released, released_at) If all session coins collected/expired, updates session status Broadcasts update via WebSocket Coin Expiration (Background Job) Runs every 60 seconds (cron job or scheduler) Finds GeneratedCoins where ttl_expires_at < NOW() and status = 'active' For each expired coin: Set status = 'expired' Increment sponsor's quantity_available (returns to inventory) Update EscrowTracking (status: reserved) Updates session status if all coins collected/expired Broadcasts updates via WebSocket Session Abandon (Player) POST /api/player/session/abandon Accepts: player_id, session_id Expires all remaining active coins (same as expiration logic) Sets session status = 'abandoned' Broadcasts update via WebSocket Leaderboard & Stats (Player) GET /api/player/leaderboard?player_id={id} Ranks all players by total_donated (ties broken by total_coins_collected) Returns: player's rank, 4 above, 4 below (with their stats) GET /api/player/stats?player_id={id} Returns time-series data: cumulative coins collected and amount donated over time Coin History (Player) GET /api/player/history?player_id={id} Returns all collected coins with location, value, timestamp Sponsor Dashboard Stats GET /api/sponsor/stats?sponsor_id={id} Returns: total purchased, inventory count, active count, collected count, expired count Returns time-series donation data for graphing Sponsor Coin Tracking GET /api/sponsor/coins?sponsor_id={id}&filter={all|active|collected|expired} Returns all coins funded by this sponsor with locations and statuses Supports filtering by status Payment Webhook (Stripe) POST /api/webhooks/stripe Receives webhook POST from Stripe after successful payment Validates webhook signature (critical for security) Extracts payment metadata (sponsor_id, coin quantities) Adds coins to SponsorCoinInventory (quantity_available, quantity_purchased) Creates EscrowTracking records (status: held) Updates SponsorProfile (total_coins_purchased) Broadcasts inventory update via WebSocket 4.3 Real-Time Updates Use WebSockets (e.g., Socket.io) or Server-Sent Events (SSE). Broadcast events: session:started — New session created coin:collected — Coin collected by player coin:expired — Coin expired session:ended — Session completed/abandoned inventory:updated — Sponsor inventory changed Clients subscribe to relevant events based on their role and current view. 5. Payment & Escrow Flow Sponsor selects coin quantities and clicks "Purchase". Frontend redirects to Stripe Checkout (use Stripe.js and create a checkout session). After successful payment, Stripe sends a webhook to /api/webhooks/stripe. Backend validates the webhook signature (must verify it's from Stripe). Backend adds coins to sponsor inventory and creates escrow records (status: held). When a coin is placed in a player session, escrow remains held. If player collects the coin, escrow changes to released (donation to BHF). If coin expires, escrow changes to reserved (funds stay in escrow, coin returns to inventory). For MVP: Use Stripe Test Mode. Do not process real payments. Use Stripe's test webhook events. 6. Key Technical Requirements 6.1 Frontend Stack Framework: React or Vue.js (recommend React for better PWA tooling) State Management: React Context + Hooks or Zustand Routing: React Router (for Player/Sponsor views) Maps: Leaflet.js (open-source) or Mapbox GL JS Charts: Chart.js or Recharts Real-time: Socket.io-client or native EventSource (SSE) PWA: Workbox (for service worker), manifest.json Styling: Tailwind CSS or styled-components 6.2 Backend Stack Runtime: Node.js Framework: Express.js Database: PostgreSQL (with PostGIS for spatial queries) or MongoDB Real-time: Socket.io or SSE Authentication: JWT with httpOnly cookies Payment: Stripe SDK Background Jobs: node-cron or bull (for coin expiration) 6.3 Geolocation Handling Use navigator.geolocation.getCurrentPosition() for one-time location Use navigator.geolocation.watchPosition() for continuous tracking during sessions Handle permission denied, timeout, and unavailable errors gracefully On iOS Safari, HTTPS is required for geolocation (ensure deployment uses HTTPS) Server-side distance calculation: Use Haversine formula to verify collection distance 6.4 Key Constraints Charity: British Heart Foundation (label clearly in both Player and Sponsor UIs) Location permission: Mandatory for Player mode; handle denial gracefully Coin placement: Always 1–2 km from player (not configurable) Collection radius: Always 10 metres, enforced server-side Session limit: One active session per player Leaderboard: Global, ranked by total_donated (then total_coins_collected) Stats: All-time cumulative only Real-time: Both Player and Sponsor UIs must update live when statuses change Code comments: Every critical function (session management, distance checks, escrow transitions, coin generation, webhook validation) must have clear comments explaining logic 6.5 Security & Validation Validate all inputs on the backend (player position, coin_id, session_id) Verify Stripe webhook signatures to prevent spoofing Rate limit coin collection attempts to prevent abuse Use HTTPS in production (required for geolocation and PWA) Store JWTs in httpOnly cookies (not localStorage) 7. MVP Deliverables A fully functional PWA with Player and Sponsor interfaces accessible from one app Installable on mobile devices (manifest + service worker) Working authentication and role selection Player: Session creation, real-time map, coin collection, history Sponsor: Coin purchase (Stripe test mode), inventory tracking, coin tracking map Real-time updates across both interfaces Leaderboard and stats graphs Background job for coin expiration Stripe webhook handler (test mode, with signature validation) Clear code comments explaining all critical logic README with setup instructions, database schema, and API documentation 8. File Structure (Suggested) /give-go ├── /client # PWA Frontend │ ├── /public │ │ ├── manifest.json │ │ ├── service-worker.js │ │ └── /icons │ ├── /src │ │ ├── /components │ │ │ ├── /Player │ │ │ │ ├── PlayerDashboard.jsx │ │ │ │ ├── SessionMap.jsx │ │ │ │ ├── CoinHistory.jsx │ │ │ │ └── Leaderboard.jsx │ │ │ ├── /Sponsor │ │ │ │ ├── SponsorDashboard.jsx │ │ │ │ ├── CoinPurchase.jsx │ │ │ │ └── CoinTrackingMap.jsx │ │ │ ├── /Shared │ │ │ │ ├── Login.jsx │ │ │ │ ├── RoleSelector.jsx │ │ │ │ └── Navigation.jsx │ │ ├── /hooks │ │ │ ├── useGeolocation.js │ │ │ ├── useWebSocket.js │ │ │ └── useAuth.js │ │ ├── /utils │ │ │ ├── distance.js # Haversine formula (client-side preview) │ │ │ └── api.js │ │ ├── App.jsx │ │ └── index.js ├── /server # Backend │ ├── /routes │ │ ├── auth.js │ │ ├── player.js │ │ ├── sponsor.js │ │ └── webhooks.js │ ├── /controllers │ │ ├── sessionController.js │ │ ├── coinController.js │ │ └── paymentController.js │ ├── /models │ │ ├── User.js │ │ ├── PlayerProfile.js │ │ ├── SponsorProfile.js │ │ ├── CoinType.js │ │ ├── GeneratedCoin.js │ │ ├── Session.js │ │ └── Escrow.js │ ├── /middleware │ │ ├── auth.js │ │ └── validation.js │ ├── /utils │ │ ├── distance.js # Haversine formula (server-side verification) │ │ └── coinExpiration.js # Background job │ ├── /websocket │ │ └── socketHandlers.js │ ├── server.js │ └── database.js ├── package.json └── README.md 9. Testing Scenarios Ensure the app handles these scenarios: Player starts session with no inventory → Shows "no coins available" message Player tries to start second session → Prevented, redirected to active session Player collects coin > 10m away → Rejected by server Player collects coin ≤ 10m → Collection succeeds, stats update Coin expires during session → Removed from map, returned to sponsor inventory Player gives up mid-session → All coins expire, session marked abandoned Sponsor purchases coins → Payment succeeds, inventory updates in real time Sponsor views tracking map → Sees active/collected/expired coins with filters Location permission denied → Graceful error with retry option Offline → Online → Service worker caches assets, app works when reconnected 10. Final Notes Stub Stripe payments: Use test mode and Stripe CLI for webhook testing Stub BHF fund transfers: No actual money movement in MVP Comments are mandatory: Explain session logic, distance checks, escrow transitions Real-time is critical: Use WebSockets or SSE for live updates PWA must install smoothly: Test on iOS Safari and Android Chrome Geolocation must be robust: Handle errors, request permissions clearly This PWA should be production-ready for demo purposes and fully functional end-to-end.